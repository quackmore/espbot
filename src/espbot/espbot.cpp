/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revision 42):
 * <quackmore-ff@yahoo.com> wrote this file.  As long as you retain this notice
 * you can do whatever you want with this stuff. If we meet some day, and you 
 * think this stuff is worth it, you can buy me a beer in return. Quackmore
 * ----------------------------------------------------------------------------
 */
// SDK includes
extern "C"
{
#include "driver_uart.h"
#include "ets_sys.h"
#include "mem.h"
#include "osapi.h"
#include "user_interface.h"
}
// local includes

#include "app.hpp"
#include "espbot.hpp"
#include "espbot_cfgfile.hpp"
#include "espbot_cron.hpp"
#include "espbot_diagnostic.hpp"
#include "espbot_event_codes.h"
#include "espbot_global.hpp"
#include "espbot_gpio.hpp"
#include "espbot_hal.h"
#include "espbot_mem_mon.hpp"
#include "espbot_mdns.hpp"
#include "espbot_http.hpp"
#include "espbot_json.hpp"
#include "espbot_spiffs.hpp"
#include "espbot_timedate.hpp"
#include "espbot_utils.hpp"
#include "espbot_webclient.hpp"
#include "espbot_wifi.hpp"
#include "spiffs_esp8266.hpp"

/*
 *  APP_RELEASE is coming from git
 *  'git --no-pager describe --tags --always --dirty'
 *  and is generated by the Makefile
 */

#ifndef APP_RELEASE
#define APP_RELEASE "Unavailable"
#endif
char *espbot_release = APP_RELEASE;

static struct
{
    char device_name[32];
} espbot_cfg;

static struct
{
    int graceful_rst_counter;
    os_timer_t graceful_rst_timer;
    uint32 lastRebootTime;
} espbot_state;

// espbot task
#define ESPBOT_TASK_QUEUE_LEN 8
static os_event_t *espbot_task_queue;

typedef enum
{
    http_server_not_running = 0,
    http_server_running_on_ap,
    http_server_running_on_sta
} espbot_http_status_t;

static void espbot_coordinator_task(os_event_t *e)
{
    static espbot_http_status_t espbot_http_status = http_server_not_running;
    switch (e->sig)
    {
    case SIG_staMode_gotIp:
        // [wifi station] got IP
        if (e->par == GOT_IP_AFTER_CONNECTION)
        {
            // new connection
            timedate_start_sntp();
            mdns_start(espbot_get_name());
            // check if there is a web server listening on esp AP interface
            if (espbot_http_status != http_server_not_running)
                espwebsvr.stop();
            espwebsvr.start(80);
            espbot_http_status = http_server_running_on_sta;
            app_init_after_wifi();
        }
        if (e->par == GOT_IP_ALREADY_CONNECTED)
        {
            // dhcp lease renewal
            timedate_stop_sntp();
            timedate_start_sntp();
            mdns_stop();
            mdns_start(espbot_get_name());
            if (espbot_http_status != http_server_not_running)
                espwebsvr.stop();
            espwebsvr.start(80);
            espbot_http_status = http_server_running_on_sta;
        }
        break;
    case SIG_staMode_disconnected:
        // [wifi station] disconnected
        timedate_stop_sntp();
        mdns_stop();
        // stop the webserver only if it is running on the WIFI STATION interface
        if (espbot_http_status == http_server_running_on_sta)
        {
            espwebsvr.stop();
            espbot_http_status = http_server_not_running;
        }
        app_deinit_on_wifi_disconnect();
        break;
    case SIG_softapMode_staConnected:
        // [wifi station+AP] station connected
        break;
    case SIG_softapMode_staDisconnected:
        // [wifi station+AP] station disconnected
        break;
    case SIG_softapMode_ready:
        // don't stop the web server if it's already listening on WIFI AP interface
        if (espbot_http_status == http_server_running_on_sta)
        {
            espwebsvr.stop();
            espbot_http_status = http_server_not_running;
        }
        // don't start the web server if it's already listening on WIFI AP interface
        if (espbot_http_status == http_server_not_running)
        {
            espwebsvr.start(80);
            espbot_http_status = http_server_running_on_ap;
        }
        app_init_after_wifi();
        break;
    case SIG_http_checkPendingResponse:
        // getting here from webserver after send callback completed
        http_check_pending_send();
        break;
    case SIG_next_function:
        // execute a function
        {
            void (*command)(void) = (void (*)(void))e->par;
            if (command)
                command();
        }
        break;
    default:
        break;
    }
}

static void heartbeat_cb(void)
{
    TRACE("ESPBOT HEARTBEAT: ---------------------------------------------------");
    uint32 current_timestamp = timedate_get_timestamp();
    TRACE("ESPBOT HEARTBEAT: [%d] [UTC+1] %s", current_timestamp, timedate_get_timestr(current_timestamp));
    TRACE("ESPBOT HEARTBEAT: Available heap size: %d", system_get_free_heap_size());
}

uint32 espbot_get_last_reboot_time(void)
{
    return espbot_state.lastRebootTime;
}

char *espbot_get_name(void)
{
    return espbot_cfg.device_name;
}

char *espbot_get_version(void)
{
    return espbot_release;
}

void espbot_set_name(char *t_name)
{
    os_memset(espbot_cfg.device_name, 0, 32);
    if (os_strlen(t_name) > 31)
    {
        dia_warn_evnt(ESPOT_SET_NAME_TRUNCATED);
        WARN("espbot_set_name truncating name to 32 characters");
    }
    os_strncpy(espbot_cfg.device_name, t_name, 31);
}

#define ESPBOT_FILENAME ((char *)f_str("espbot.cfg"))

static int espbot_restore_cfg(void)
{
    ALL("espbot_restore_cfg");

    if (!Espfile::exists(ESPBOT_FILENAME))
        return CFG_cantRestore;
    Cfgfile cfgfile(ESPBOT_FILENAME);
    espmem.stack_mon();
    char device_name[32];
    os_memset(device_name, 0, 32);
    cfgfile.getStr(f_str("espbot_name"), device_name, 31);
    if (cfgfile.getErr() != JSON_noerr)
    {
        dia_error_evnt(ESPBOT_RESTORE_CFG_ERROR);
        ERROR("espbot_restore_cfg error");
        return CFG_error;
    }
    os_strncpy(espbot_cfg.device_name, device_name, 32);
    return CFG_ok;
}

static int espbot_saved_cfg_updated(void)
{
    ALL("espbot_saved_cfg_updated");
    if (!Espfile::exists(ESPBOT_FILENAME))
    {
        return CFG_notUpdated;
    }
    Cfgfile cfgfile(ESPBOT_FILENAME);
    char device_name[32];
    os_memset(device_name, 0, 32);
    cfgfile.getStr(f_str("espbot_name"), device_name, 31);
    espmem.stack_mon();
    if (cfgfile.getErr() != JSON_noerr)
    {
        // no need to raise an error, the cfg file will be overwritten
        // dia_error_evnt(ESPBOT_SAVED_CFG_UPDATED_ERROR);
        // ERROR("espbot_saved_cfg_updated error");
        return CFG_error;
    }
    if (os_strcmp(espbot_cfg.device_name, device_name) != 0)
    {
        return CFG_notUpdated;
    }
    return CFG_ok;
}

char *espbot_cfg_json_stringify(char *dest, int len)
{
    // {"espbot_name":0}
    int msg_len = 17 + 1;
    char *msg;
    if (dest == NULL)
    {
        msg = new char[msg_len];
        if (msg == NULL)
        {
            dia_error_evnt(ESPBOT_CFG_STRINGIFY_HEAP_EXHAUSTED, msg_len);
            ERROR("espbot_cfg_json_stringify heap exhausted [%d]", msg_len);
            return NULL;
        }
    }
    else
    {
        msg = dest;
        if (len < msg_len)
        {
            *msg = 0;
            return msg;
        }
    }
    fs_sprintf(msg,
               "{\"espbot_name\":%d}",
               espbot_cfg.device_name);
    return msg;
}


int espbot_cfg_save(void)
{
    ALL("espbot_cfg_save");
    if (espbot_saved_cfg_updated() == CFG_ok)
        return CFG_ok;
    Cfgfile cfgfile(ESPBOT_FILENAME);
    espmem.stack_mon();
    if (cfgfile.clear() != SPIFFS_OK)
        return CFG_error;
    char str[18];
    espbot_cfg_json_stringify(str, 18);
    int res = cfgfile.n_append(str, os_strlen(str));
    if (res < SPIFFS_OK)
        return CFG_error;
    return CFG_ok;
}

// GRACEFUL RESET
// 1) wait 300 ms
// 2) stop the webserver
// 3) wait 200 ms
// 4) stop the wifi
// 5) wait 200 ms
// 6) system_restart

static void graceful_reset(void *t_reset)
{
    espbot_state.graceful_rst_counter++;
    espbot_reset((int)t_reset);
}

void espbot_reset(int t_reset)
{
    switch (espbot_state.graceful_rst_counter)
    {
    case 0:
        // waiting for completion of any http com
        os_timer_setfn(&espbot_state.graceful_rst_timer, (os_timer_func_t *)graceful_reset, (void *)t_reset);
        os_timer_arm(&espbot_state.graceful_rst_timer, 300, 0);
        break;
    case 1:
        // stop services over wifi
        cron_stop();
        espwebsvr.stop();
        mdns_stop();
        timedate_stop_sntp();
        os_timer_setfn(&espbot_state.graceful_rst_timer, (os_timer_func_t *)graceful_reset, (void *)t_reset);
        os_timer_arm(&espbot_state.graceful_rst_timer, 200, 0);
        break;
    case 2:
        // stop wifi
        wifi_set_opmode_current(NULL_MODE);
        os_timer_setfn(&espbot_state.graceful_rst_timer, (os_timer_func_t *)graceful_reset, (void *)t_reset);
        os_timer_arm(&espbot_state.graceful_rst_timer, 100, 0);
        break;
    case 3:
        // reset
        if (t_reset == ESPBOT_restart)
            system_restart();
        if (t_reset == ESPBOT_rebootAfterOta)
            system_upgrade_reboot();
        break;
    default:
        break;
    }
}

// execute a function from a task
void next_function(void (*fun)(void))
{
    system_os_post(USER_TASK_PRIO_0, SIG_next_function, (ETSParam)fun);
}

void espbot_init(void)
{
    // BEFORE FILE SYSTEM BECOMES AVAILABLE
    // init functions will use default cfg only
    system_set_os_print(1);    // enable log print
    espmem.init();             //
    timedate_init_essential(); // cause diagnostic will use timestamp
    gpio_init();               // cause it's used by diagnostic
    dia_init_essential();      // default cfg

    // MOUNT THE FILE SYSTEM
    esp_spiffs_mount();

    // FILE SYSTEM AVAILABLE: from now on the init functions can restore the cfg saved into flash
    dia_init_custom();
    timedate_init();

    // set default name
    fs_sprintf(espbot_cfg.device_name, "ESPBOT-%d", system_get_chip_id());
    if (espbot_restore_cfg() != CFG_ok)
    {
        dia_warn_evnt(ESPBOT_INIT_DEFAULT_CFG);
        WARN("espbot_init no cfg available, espbot name set to %s", espbot_get_name());
    }
    os_timer_disarm(&espbot_state.graceful_rst_timer);
    espbot_state.graceful_rst_counter = 0;
    // setup the ESPBOT task
    espbot_task_queue = new os_event_t[ESPBOT_TASK_QUEUE_LEN];
    system_os_task(espbot_coordinator_task, USER_TASK_PRIO_0, espbot_task_queue, ESPBOT_TASK_QUEUE_LEN);
    // save the boot timestamp
    espbot_state.lastRebootTime = timedate_get_timestamp();

    // BEFORE WIFI
    mdns_init();
    esp_ota.init();
    http_init();
    espwebsvr.init();
    init_webclients_data_stuctures();
    cron_init();
    app_init_before_wifi();

    // WIFI START
    espwifi_init();
}